import java_cup.runtime.*;
import java.lang.Number;
import java.util.*;

parser code {:
    public void syntax_error(Symbol cur_token) {
        System.err.println("----error----");
        System.err.println("line :"+ cur_token.left + " column :"+ cur_token.right);
        report_error("syntax_error", null);
    }
    public void unrecovered_syntax_error(Symbol cur_token) {
        syntax_error(cur_token);
        System.err.println("----fin----");
    }
:}

action code {:
  int registreCourant = 0;
  int registreAvantTimes = -1; // Times, div et mod
:}

init with {:
//Liste d'Instructions
//Table de variables HashMap <variable, type>
//Pile de HashMap<ListeInstruction, HashMap<variable, type>> à voir en détail
:}

terminal IF, THEN, ELSE;
terminal FOR, WHILE;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF, NOT, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, MINUS_U, NOT_U;
terminal EQUALS, AFFECT;
terminal LRBRA, RRBRA, LSBRA, RSBRA, SEMIC, COMMA, ENUM_TYPE, ENUM_OP;
terminal RBRACE, LBRACE;
//Rounded bracket ( ) RBRA
//Square bracket [ ]  SBRA
//Brace  { } BRACES

terminal Integer INT;
terminal Float REAL;
terminal String ID;

non terminal Instruction affectation;
non terminal Instruction instructions;
non terminal Instruction instruction_if, instruction_while, instruction_for;
non terminal Expression expression;
non terminal Expression expression_variable, expression_arith, expression_bool;
non terminal Expression expression_numerique, increment;

precedence left AND, OR;
precedence left LT, GT, GE, LE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE; // Vérifier la précédence de MOD <<<<
precedence left MOD;
precedence left MINUS_U, NOT_U;

start with instructions;

instructions ::= affectation instructions
              | instruction_for instructions
              | instruction_while instructions
              | instruction_if instructions {: :}
              | // vide, fin parsing
              ;

affectation ::= ENUM_TYPE expression_variable:id AFFECT expression_arith:exp SEMIC  {: Instruction aff = new Affectation(id, exp);
                                                                                       aff.verifier();
                                                                                       //ajout du type dans une table de HashMap<variable, type>
                                                                                       System.out.println(aff.evaluer(registreCourant - 1));
                                                                                       registreCourant = 0; 
                                                                                    :}
             |  expression_variable:id AFFECT expression_arith:exp SEMIC            {: Instruction aff = new Affectation(id, exp);
                                                                                       aff.verifier();
                                                                                       System.out.println(aff.evaluer(registreCourant - 1));
                                                                                       registreCourant = 0; 
                                                                                    :}
             ;

instruction_if ::= IF LRBRA expression_bool:condition RRBRA THEN                    
                        LBRACE instructions:blocIf RBRACE
                        ELSE LBRACE instructions:blocElse RBRACE

                |  IF LRBRA expression_bool:condition RRBRA THEN                    {:  :}
                        LBRACE instructions:blocIf RBRACE                           {: /*Instruction i = new IfThenElse(blocIf, condition);
                                                                                       Instructions all = new Instructions(i);
                                                                                       System.out.println(all.evaluer(0)); */
                                                                                    :}
                ;


instruction_for ::= FOR LRBRA affectation SEMIC expression_bool:condition SEMIC increment RRBRA
                        LBRACE instructions RBRACE
                 ;

instruction_while ::= WHILE LRBRA expression_bool:condition RRBRA
                         LBRACE instructions RBRACE
                   ;

//on verra plus tard pour les affectations de booleens (pas encore un type déclaré)

expression_variable  ::= ID:id      {:  Expression variable = new Variable(id);
                                        variable.verifier();
                                        RESULT = variable; 
                                    :}
                      | ID:id LSBRA expression_arith:exp RSBRA {: RESULT = new VariableTableau(id, exp); :}
                      ;

expression_numerique ::= INT:nb    {: RESULT = new Value(nb); :}
                      |  REAL:nb   {: RESULT = new Value(nb); :}
                      ;


expression_arith ::= expression_arith:e1 PLUS   expression_arith:e2     {:  RESULT = new OperationArithmetique(e1, e2, EnumOp.PLUS,   registreCourant); 
                                                                            int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.PLUS, registreCourant++, registreAvantTimes); 
                                                                            if(tmp != -1) { registreAvantTimes = tmp; } 
                                                                        :}
                  |  expression_arith:e1 MINUS  expression_arith:e2     {:  RESULT = new OperationArithmetique(e1, e2, EnumOp.MINUS,  registreCourant); 
                                                                            int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.MINUS, registreCourant++, registreAvantTimes); 
                                                                            if(tmp != -1) { registreAvantTimes = tmp; } 
                                                                        :}
                  |  expression_arith:e1 TIMES  expression_arith:e2     {:  RESULT = new OperationArithmetique(e1, e2, EnumOp.TIMES,  registreCourant); 
                                                                            int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.TIMES, registreCourant++, registreAvantTimes); 
                                                                            if(tmp != -1) { registreAvantTimes = tmp; } 
                                                                        :}
                  |  expression_arith:e1 DIVIDE expression_arith:e2     {:  RESULT = new OperationArithmetique(e1, e2, EnumOp.DIVIDE, registreCourant); 
                                                                            int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.DIVIDE, registreCourant++, registreAvantTimes); 
                                                                            if(tmp != -1) { registreAvantTimes = tmp; } 
                                                                        :}
                  |  expression_arith:e1 MOD    expression_arith:e2     {:  RESULT = new OperationArithmetique(e1, e2, EnumOp.MOD,    registreCourant); 
                                                                            int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.MOD, registreCourant++, registreAvantTimes); 
                                                                            if(tmp != -1) { registreAvantTimes = tmp; } 
                                                                        :}
                  |  LRBRA expression_arith:exp RRBRA                   {:  RESULT = exp; :}
                  |  MINUS expression_arith:exp %prec MINUS_U           {:  RESULT = new OperationArithmetique(exp, EnumOp.MINUS_U, registreCourant);    
                                                                            int tmp = OperationArithmetique.genCodeUnaire(exp, EnumOp.MOD, registreCourant++, registreAvantTimes); 
                                                                            if(tmp != -1) { registreAvantTimes = tmp; } 
                                                                        :}
                  |  expression_variable:exp                            {:  RESULT = exp; :}
                  |  expression_numerique:exp                           {:  RESULT = exp; :}
                  ;
// A voir : verification à la volée / génération du code
// ou bien, génération en sortie de bloc : au moment du dépilement d'un
// "environnement", géneration du code 3-adress (génération en buffer
// d'Environnement)

expression_bool ::= expression_arith:e1 AND     expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.AND);     :}
                 |  expression_arith:e1 OR      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.OR);      :}
                 |  expression_arith:e1 DIFF    expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.DIFF);    :}
                 |  expression_arith:e1 LT      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.LT);      :}
                 |  expression_arith:e1 GT      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.GT);      :}
                 |  expression_arith:e1 GE      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.GE);      :}
                 |  expression_arith:e1 LE      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.LE);      :}
                 |  expression_arith:e1 EQ      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.EQUALS);  :}

                 |  expression_bool:b1 AND      expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.AND);     :}
                 |  expression_bool:b1 OR       expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.OR);      :}
                 |  expression_bool:b1 DIFF     expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.DIFF);    :}
                 |  expression_bool:b1 EQ       expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.EQUALS);  :}

                 |  NOT expression_bool:b                               {:  RESULT = new OperationBooleenne(b, EnumOp.NOT); :} %prec NOT_U
                 |  LRBRA expression_bool:b RRBRA                       {:  RESULT = b;   :}
                 //| expression_numerique:exp                             {:    RESULT = exp; :}
                 | expression_arith:exp                                 {:  RESULT = exp; :}
                 ;
// Revoir la grammaire pour inclure les expressions booleennes




//non terminal P, D, Ss, T, L, I, S, E;

/*
start with P;

P ::= D Ss                      {: :}
    ;

D ::= T:type L SEMIC            {: :}
    ;

T ::= ENUMTYPE                 {:  :}
    ;

L ::= L COMMA I:name            {:  :}
    | I:name                    {:  :}
    ;

I ::= ID:name                   {: :}
    | I:name LPAR INT RPAR   {: :}
    ;

Ss ::= Ss S {: :}
    |     S {: :}
    ;

S ::= ID:var1 EQUALS E SEMIC {: :}
    ;

E ::= I:name LPAR INT RPAR   {: :}
    | INT                       {:  :}
    | REAL                      {:  :}
    ;
*/
