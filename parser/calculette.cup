import java_cup.runtime.*;
import java.lang.Number;
import java.util.*;

parser code {:
    public void syntax_error(Symbol cur_token) {
        System.err.println("----error----");
        System.err.println("line :"+ cur_token.left + " column :"+ cur_token.right);
        report_error("syntax_error", null);
    }
    public void unrecovered_syntax_error(Symbol cur_token) {
        syntax_error(cur_token);
        System.err.println("----fin----");
    }
:}

action code {:
//  int registreCourant = 0;
:}

init with {:
//Liste d'Instructions
//Table de variables HashMap <variable, type>
//Pile de HashMap<ListeInstruction, HashMap<variable, type>> à voir en détail
:}

terminal IF, ELSE;
terminal FOR, WHILE, DO;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF, NOT, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, MINUS_U, NOT_U;
terminal EQUALS, AFFECT;
terminal LRBRA, RRBRA, LSBRA, RSBRA, SEMIC, COMMA, ENUM_TYPE, ENUM_OP, POINTER;
terminal RBRACE, LBRACE;
terminal INC, DEC;
//Rounded bracket ( ) RBRA
//Square bracket [ ]  SBRA
//Brace  { } BRACES

terminal Integer INT;
terminal Float REAL;
terminal String ID;

non terminal beginning;

non terminal Instruction instruction, bloc_instruction;
non terminal Instruction affectation, instruction_if, instruction_while, instruction_for, increment;
non terminal LinkedList<Instruction> liste_instruction;

non terminal Expression expression_variable, expression_arith, expression_bool, expression_arithBool, expression;
non terminal Expression expression_numerique;


precedence left AND, OR;
precedence left LT, GT, GE, LE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left MOD;
precedence left MINUS_U, NOT_U;
precedence right ELSE;

start with beginning;

beginning ::= beginning instruction:inst {: Label suivant = new Label();
                                            inst.genererCode(suivant);
                                            System.out.println("\n" + suivant + ":"); :}
            | /* Fin du parsing */
            ;

instruction ::= affectation:affInstruction                      {: RESULT = affInstruction; :}
             |  instruction_for:forInstruction                  {: RESULT = forInstruction; :}
             |  instruction_while:whileInstruction              {: RESULT = whileInstruction; :}
             |  instruction_if:ifInstruction                    {: RESULT = ifInstruction; :}
             |  bloc_instruction:blocInstruction                {: RESULT = blocInstruction; :}
             ;

affectation ::= ENUM_TYPE expression_variable:id AFFECT expression:exp SEMIC          {: RESULT = new Affectation(id, exp); :}
             |  expression_variable:id AFFECT expression:exp SEMIC                    {: RESULT = new Affectation(id, exp); :}
             |  POINTER ENUM_TYPE expression_variable:id AFFECT expression:exp SEMIC  {: RESULT = new Affectation(id, exp); :}
             ;

instruction_if ::= IF  expression:condition
                        instruction:blocIf
                        ELSE instruction:blocElse                                     {: RESULT = new IfThenElse(condition, blocIf, blocElse); :}

                |  IF  expression:condition
                        instruction:blocIf                                            {: RESULT = new IfThen(condition, blocIf); :}
                ;


instruction_for ::= FOR LRBRA affectation:affect expression:condition SEMIC increment:inc RRBRA
                        instruction:blocFor                                           {: RESULT = new For(affect, condition, inc, blocFor); :}
                 ;

increment ::= /*ID:id INC   //{: RESULT = ; :}
            | INC ID:id   //{: RESULT = ; :}
            | ID:id DEC   //{: RESULT = ; :}
            | DEC ID:id   //{: RESULT = ; :}
            | */expression_variable:id AFFECT expression:exp                          {: RESULT = new Affectation(id, exp); :}
            | {: RESULT = null; :}
            ;

instruction_while ::= WHILE expression:condition
                         instruction:blocWhile                                        {: RESULT = new While(condition, blocWhile); :}
                   |  DO
                        instruction:blocWhile
                      WHILE expression:condition SEMIC                                {: RESULT = new DoWhile(blocWhile, condition); :}
                   ;

bloc_instruction ::= LBRACE liste_instruction:bloc RBRACE                             {: RESULT = new BlocInstruction(bloc); :}
                  ;

liste_instruction ::= liste_instruction:list instruction:nouvelleInstruction          {: list.add(nouvelleInstruction); //append en fin de liste
                                                                                       RESULT = list;  :}
                   |                                                                  {: RESULT = new LinkedList<Instruction>(); :}
                   ;


expression_numerique ::= INT:nb    {: RESULT = new Value(nb); :}
                      |  REAL:nb   {: RESULT = new Value(nb); :}
                      ;

expression_variable ::= ID:id                                           {: RESULT = new Variable(id); :}
                     |  ID:id LSBRA expression:exp RSBRA                {: RESULT = new VariableTableau(id, exp); :}
                     ;


/*expression_arith ::= expression_arith:e1 PLUS   expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.PLUS); :}
                  |  expression_arith:e1 MINUS  expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MINUS); :}
                  |  expression_arith:e1 TIMES  expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.TIMES); :}
                  |  expression_arith:e1 DIVIDE expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.DIVIDE); :}
                  |  expression_arith:e1 MOD    expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MOD); :}
                  |  MINUS expression_arith:exp                         {: RESULT = new ArithmetiqueUnaire(exp, EnumOp.MINUS); :}
                  |  LRBRA expression_arith:exp RRBRA                   {: RESULT = exp; :}
                  |  expression_variable:exp                            {: RESULT = exp; :}
                  |  expression_numerique:exp                           {: RESULT = exp; :}
                  ;

expression_arithBool ::= expression_arithBool:e1 PLUS   expression_arithBool:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.PLUS); :}
                      |  expression_arithBool:e1 MINUS  expression_arithBool:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MINUS); :}
                      |  expression_arithBool:e1 TIMES  expression_arithBool:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.TIMES); :}
                      |  expression_arithBool:e1 DIVIDE expression_arithBool:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.DIVIDE); :}
                      |  expression_arithBool:e1 MOD    expression_arithBool:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MOD); :}
                      |  MINUS expression_arithBool:exp                             {: RESULT = new ArithmetiqueUnaire(exp, EnumOp.MINUS); :}

                      |  expression_arithBool:e1 AND     expression_arithBool:e2    {: RESULT = new AndBool(e1, e2);     :}
                      |  expression_arithBool:e1 OR      expression_arithBool:e2    {: RESULT = new OrBool(e1, e2);      :}
                      |  expression_arithBool:e1 DIFF    expression_arithBool:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.DIFF);    :}
                      |  expression_arithBool:e1 LT      expression_arithBool:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.LT);      :}
                      |  expression_arithBool:e1 GT      expression_arithBool:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.GT);      :}
                      |  expression_arithBool:e1 GE      expression_arithBool:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.GE);      :}
                      |  expression_arithBool:e1 LE      expression_arithBool:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.LE);      :}
                      |  expression_arithBool:e1 EQ      expression_arithBool:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.EQUALS);  :}

                      |  expression_variable:exp                                    {: RESULT = exp; :}
                      |  expression_numerique:exp                                   {: RESULT = exp; :}
                      ;

expression_bool ::= expression_bool:b1 AND      expression_bool:b2                  {: RESULT = new AndBool(b1, b2);     :}
                 |  expression_bool:b1 OR       expression_bool:b2                  {: RESULT = new OrBool(b1, b2);      :}
                 |  expression_bool:b1 DIFF     expression_bool:b2                  {: RESULT = new ComparaisonBool(b1, b2, EnumOp.DIFF);    :}
                 |  expression_bool:b1 EQ       expression_bool:b2                  {: RESULT = new ComparaisonBool(b1, b2, EnumOp.EQUALS);  :}

                 |  NOT expression_bool:b                                           {: RESULT = new NotBool(b); :} %prec NOT_U
                 |  LRBRA expression_bool:b RRBRA                                   {: RESULT = b;   :}

                 |  expression_arithBool:exp                                        {:  RESULT = exp; :}
                 ;*/

expression ::= expression:e1 PLUS   expression:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.PLUS); :}
            |  expression:e1 MINUS  expression:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MINUS); :}
            |  expression:e1 TIMES  expression:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.TIMES); :}
            |  expression:e1 DIVIDE expression:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.DIVIDE); :}
            |  expression:e1 MOD    expression:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MOD); :}
            |  MINUS expression:exp                   {: RESULT = new ArithmetiqueUnaire(exp, EnumOp.MINUS); :}

            |  expression:e1 AND     expression:e2    {: RESULT = new AndBool(e1, e2);     :}
            |  expression:e1 OR      expression:e2    {: RESULT = new OrBool(e1, e2);      :}
            |  expression:e1 DIFF    expression:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.DIFF);    :}
            |  expression:e1 LT      expression:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.LT);      :}
            |  expression:e1 GT      expression:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.GT);      :}
            |  expression:e1 GE      expression:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.GE);      :}
            |  expression:e1 LE      expression:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.LE);      :}
            |  expression:e1 EQ      expression:e2    {: RESULT = new ComparaisonBool(e1, e2, EnumOp.EQUALS);  :}

            |  NOT expression:b                       {: RESULT = new NotBool(b); :} %prec NOT_U
            |  LRBRA expression:b RRBRA               {: RESULT = b; :}

            |  expression_variable:exp                {: RESULT = exp; :}
            |  expression_numerique:exp               {: RESULT = exp; :}
            ;                
