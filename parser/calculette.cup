import java_cup.runtime.*;
import java.lang.Number;
import java.util.*;

parser code {:
    public void syntax_error(Symbol cur_token) {
        System.err.println("----error----");
        System.err.println("line :"+ cur_token.left + " column :"+ cur_token.right);
        report_error("syntax_error", null);
    }
    public void unrecovered_syntax_error(Symbol cur_token) {
        syntax_error(cur_token);
        System.err.println("----fin----");
    }
:}

action code {:
//  int registreCourant = 0;
:}

init with {:
//Liste d'Instructions
//Table de variables HashMap <variable, type>
//Pile de HashMap<ListeInstruction, HashMap<variable, type>> à voir en détail
:}

terminal IF, THEN, ELSE;
terminal FOR, WHILE;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF, NOT, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, MINUS_U, NOT_U;
terminal EQUALS, AFFECT;
terminal LRBRA, RRBRA, LSBRA, RSBRA, SEMIC, COMMA, ENUM_TYPE, ENUM_OP;
terminal RBRACE, LBRACE;
//Rounded bracket ( ) RBRA
//Square bracket [ ]  SBRA
//Brace  { } BRACES

terminal Integer INT;
terminal Float REAL;
terminal String ID;

non terminal beginning;

non terminal Instruction instruction, bloc_instruction;
non terminal Instruction affectation, instruction_if, instruction_while, instruction_for;
non terminal LinkedList<Instruction> liste_instruction;

non terminal Expression expression_variable, expression_arith, expression_bool;
non terminal Expression expression_numerique, increment;


precedence left AND, OR;
precedence left LT, GT, GE, LE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left MOD;
precedence left MINUS_U, NOT_U;
precedence right THEN, ELSE;

start with beginning;

beginning ::= beginning instruction:inst {: Label suivant = new Label();
                                            inst.genererCode(suivant);
                                            System.out.println("\n" + suivant + ":"); :}
            | /* Fin du parsing */
            ;

instruction ::= affectation:affInstruction                      {: RESULT = affInstruction; :}
             |  instruction_for:forInstruction                  {: RESULT = forInstruction; :}
             |  instruction_while:whileInstruction              {: RESULT = whileInstruction; :}
             |  instruction_if:ifInstruction                    {: RESULT = ifInstruction; :}
             |  bloc_instruction:blocInstruction                {: RESULT = blocInstruction; :}
             ;

affectation ::= ENUM_TYPE expression_variable:id AFFECT expression_arith:exp SEMIC  {: RESULT = new Affectation(id, exp); :}
             |  expression_variable:id AFFECT expression_arith:exp SEMIC            {: RESULT = new Affectation(id, exp); :}
             ;

instruction_if ::= IF LRBRA expression_bool:condition RRBRA THEN
                        instruction:blocIf
                        ELSE instruction:blocElse                                   {: RESULT = new IfThenElse(condition, blocIf, blocElse); :}

                |  IF LRBRA expression_bool:condition RRBRA THEN
                        instruction:blocIf                                          {: RESULT = new IfThen(condition, blocIf); :}
                ;


instruction_for ::= FOR LRBRA affectation:affect expression_bool:condition affectation:inc RRBRA
                        instruction:blocFor                                         {: RESULT = new For(affect, condition, inc, blocFor); :}
                 ;

//increment ::= ID:id

instruction_while ::= WHILE LRBRA expression_bool:condition RRBRA
                         instruction:blocWhile                                      {: RESULT = new While(condition, blocWhile); :}
                   ;

bloc_instruction ::= LBRACE liste_instruction:bloc RBRACE                           {: RESULT = new BlocInstruction(bloc); :}
                  ;

liste_instruction ::= liste_instruction:list instruction:nouvelleInstruction        {: list.add(nouvelleInstruction); //append en fin de liste
                                                                                       RESULT = list;  :}
                   |                                                                {: RESULT = new LinkedList<Instruction>(); :}
                   ;


expression_numerique ::= INT:nb    {: RESULT = new Value(nb); :}
                      |  REAL:nb   {: RESULT = new Value(nb); :}
                      ;

expression_variable ::= ID:id                                  {: RESULT = new Variable(id); :}
                     |  ID:id LSBRA expression_arith:exp RSBRA {: RESULT = new VariableTableau(id, exp); :}
                     ;


expression_arith ::= expression_arith:e1 PLUS   expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.PLUS); :}
                  |  expression_arith:e1 MINUS  expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MINUS); :}
                  |  expression_arith:e1 TIMES  expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.TIMES); :}
                  |  expression_arith:e1 DIVIDE expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.DIVIDE); :}
                  |  expression_arith:e1 MOD    expression_arith:e2     {: RESULT = new ArithmetiqueBinaire(e1, e2, EnumOp.MOD); :}
                  |  MINUS expression_arith:exp                         {: RESULT = new ArithmetiqueUnaire(exp, EnumOp.MINUS); :}
                  |  LRBRA expression_arith:exp RRBRA                   {: RESULT = exp; :}
                  |  expression_variable:exp                            {: RESULT = exp; :}
                  |  expression_numerique:exp                           {: RESULT = exp; :}
                  ;

expression_bool ::= expression_arith:e1 AND     expression_arith:e2     {:  RESULT = new AndBool(e1, e2);     :}
                 |  expression_arith:e1 OR      expression_arith:e2     {:  RESULT = new OrBool(e1, e2);      :}
                 |  expression_arith:e1 DIFF    expression_arith:e2     {:  RESULT = new ComparaisonBool(e1, e2, EnumOp.DIFF);    :}
                 |  expression_arith:e1 LT      expression_arith:e2     {:  RESULT = new ComparaisonBool(e1, e2, EnumOp.LT);      :}
                 |  expression_arith:e1 GT      expression_arith:e2     {:  RESULT = new ComparaisonBool(e1, e2, EnumOp.GT);      :}
                 |  expression_arith:e1 GE      expression_arith:e2     {:  RESULT = new ComparaisonBool(e1, e2, EnumOp.GE);      :}
                 |  expression_arith:e1 LE      expression_arith:e2     {:  RESULT = new ComparaisonBool(e1, e2, EnumOp.LE);      :}
                 |  expression_arith:e1 EQ      expression_arith:e2     {:  RESULT = new ComparaisonBool(e1, e2, EnumOp.EQUALS);  :}

                 |  expression_bool:b1 AND      expression_bool:b2      {:  RESULT = new AndBool(b1, b2);     :}
                 |  expression_bool:b1 OR       expression_bool:b2      {:  RESULT = new OrBool(b1, b2);      :}
                 |  expression_bool:b1 DIFF     expression_bool:b2      {:  RESULT = new ComparaisonBool(b1, b2, EnumOp.DIFF);    :}
                 |  expression_bool:b1 EQ       expression_bool:b2      {:  RESULT = new ComparaisonBool(b1, b2, EnumOp.EQUALS);  :}

                 |  NOT expression_bool:b                               {:  RESULT = new NotBool(b); :} %prec NOT_U
                 //|  LRBRA expression_bool:b RRBRA                       {:  RESULT = b;   :}
                 |  expression_arith:exp                                {:  RESULT = exp; :}
                 ;
