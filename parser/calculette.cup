import java_cup.runtime.*;
import java.lang.Number;
import java.util.*;

parser code {:
    public void syntax_error(Symbol cur_token) {
        System.err.println("----error----");
        System.err.println("line :"+ cur_token.left + " column :"+ cur_token.right);
        report_error("syntax_error", null);
    }
    public void unrecovered_syntax_error(Symbol cur_token) {
        syntax_error(cur_token);
        System.err.println("----fin----");
    }
:}

action code {:
  int registreCourant = 0;
  int registreAvantTimes = -1; // Times, div et mod
:}

init with {:
//Liste d'Instructions
//Table de variables HashMap <variable, type>
//Pile de HashMap<ListeInstruction, HashMap<variable, type>> à voir en détail
:}

terminal IF, THEN, ELSE;
terminal FOR, WHILE;
terminal AND, OR, LT, GT, LE, GE, EQ, DIFF, NOT, TRUE, FALSE;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD, MINUS_U, NOT_U;
terminal EQUALS, AFFECT;
terminal LRBRA, RRBRA, LSBRA, RSBRA, SEMIC, COMMA, ENUM_TYPE, ENUM_OP;
terminal RBRACE, LBRACE;
//Rounded bracket ( ) RBRA
//Square bracket [ ]  SBRA
//Brace  { } BRACES

terminal Integer INT;
terminal Float REAL;
terminal String ID;

non terminal beginning;

non terminal Instruction instruction, bloc_instruction;
non terminal Instruction affectation, instruction_if, instruction_while, instruction_for;
non terminal LinkedList<Instruction> liste_instruction;

non terminal Expression expression_variable, expression_arith, expression_bool;
non terminal Expression expression_numerique, increment;

precedence left AND, OR;
precedence left LT, GT, GE, LE, EQ, DIFF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE; // Vérifier la précédence de MOD <<<<
precedence left MOD;
precedence left MINUS_U, NOT_U;

start with beginning;

beginning ::= beginning instruction:inst {: //Gestion du numéro du label
                                             System.out.println(inst.evaluer(registreCourant - 1 /*, label*/));
                                             registreCourant = 0; :}
            | /* Fin du parsing */
            ;

instruction ::= affectation instruction
             |  instruction_for instruction
             |  instruction_while instruction
             |  instruction_if instruction
             |  bloc_instruction instruction
             ;

affectation ::= ENUM_TYPE expression_variable:id AFFECT expression_arith:exp SEMIC  {: RESULT = new Affectation(id, exp); :}
             |  expression_variable:id AFFECT expression_arith:exp SEMIC            {: RESULT = new Affectation(id, exp); :}
             ;

instruction_if ::= IF LRBRA expression_bool:condition RRBRA THEN
                        instruction:blocIf
                        ELSE instruction:blocElse                                   {: RESULT = new IfThenElse(condition, blocIf, blocElse); :}

                |  IF LRBRA expression_bool:condition RRBRA THEN
                        instruction:blocIf                                         {: RESULT = new IfThen(condition, blocIf); :}
                ;


instruction_for ::= FOR LRBRA affectation:affect SEMIC expression_bool:condition SEMIC increment:inc RRBRA
                        instruction:blocFor                                         {: RESULT = new For(affect, condition, inc, blocFor); :}
                 ;

//increment ::= ID:id

instruction_while ::= WHILE LRBRA expression_bool:condition RRBRA
                         instruction:blocWhile                                      {: RESULT = new While(condition, blocWhile); :}
                   ;

bloc_instruction ::= LBRACE liste_instruction:bloc RBRACE                           {: RESULT = new BlocInstruction(bloc); :}
                  ;

liste_instruction ::= liste_instruction:list instruction:nouvelleInstruction        {: list.add(nouvelleInstruction); //append en fin de liste
                                                                                       RESULT = list;  :}
                   |                                                                {: RESULT = new LinkedList<Instruction>(); :}
                   ;


expression_variable  ::= ID:id                                          {: RESULT = new Variable(id); :}
                      | ID:id LSBRA expression_arith:exp RSBRA          {: RESULT = new VariableTableau(id, exp); :}
                      ;

expression_numerique ::= INT:nb    {: RESULT = new Value(nb); :}
                      |  REAL:nb   {: RESULT = new Value(nb); :}
                      ;


expression_arith ::= expression_arith:e1 PLUS   expression_arith:e2     {: RESULT = new OperationArithmetique(e1, e2, EnumOp.PLUS,   registreCourant);
                                                                           int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.PLUS, registreCourant++, registreAvantTimes);
                                                                           if(tmp != -1) { registreAvantTimes = tmp; } :}
                  |  expression_arith:e1 MINUS  expression_arith:e2     {: RESULT = new OperationArithmetique(e1, e2, EnumOp.MINUS,  registreCourant);
                                                                           int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.MINUS, registreCourant++, registreAvantTimes);
                                                                           if(tmp != -1) { registreAvantTimes = tmp; } :}
                  |  expression_arith:e1 TIMES  expression_arith:e2     {: RESULT = new OperationArithmetique(e1, e2, EnumOp.TIMES,  registreCourant);
                                                                           int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.TIMES, registreCourant++, registreAvantTimes);
                                                                           if(tmp != -1) { registreAvantTimes = tmp; } :}
                  |  expression_arith:e1 DIVIDE expression_arith:e2     {: RESULT = new OperationArithmetique(e1, e2, EnumOp.DIVIDE, registreCourant);
                                                                           int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.DIVIDE, registreCourant++, registreAvantTimes);
                                                                           if(tmp != -1) { registreAvantTimes = tmp; } :}
                  |  expression_arith:e1 MOD    expression_arith:e2     {: RESULT = new OperationArithmetique(e1, e2, EnumOp.MOD,    registreCourant);
                                                                           int tmp = OperationArithmetique.genCode(e1, e2, EnumOp.MOD, registreCourant++, registreAvantTimes);
                                                                           if(tmp != -1) { registreAvantTimes = tmp; } :}
                  |  MINUS expression_arith:exp                         {: RESULT = new OperationArithmetique(exp, EnumOp.MINUS_U, registreCourant);
                                                                           int tmp = OperationArithmetique.genCodeUnaire(exp, EnumOp.MOD, registreCourant++, registreAvantTimes);
                                                                           if(tmp != -1) { registreAvantTimes = tmp; } :} %prec MINUS_U
                  |  LRBRA expression_arith:exp RRBRA                   {: RESULT = exp; :}
                  |  expression_variable:exp                            {: RESULT = exp; :}
                  |  expression_numerique:exp                           {: RESULT = exp; :}
                  ;

expression_bool ::= expression_arith:e1 AND     expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.AND);     :}
                 |  expression_arith:e1 OR      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.OR);      :}
                 |  expression_arith:e1 DIFF    expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.DIFF);    :}
                 |  expression_arith:e1 LT      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.LT);      :}
                 |  expression_arith:e1 GT      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.GT);      :}
                 |  expression_arith:e1 GE      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.GE);      :}
                 |  expression_arith:e1 LE      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.LE);      :}
                 |  expression_arith:e1 EQ      expression_arith:e2     {:  RESULT = new OperationBooleenne(e1, e2, EnumOp.EQUALS);  :}

                 |  expression_bool:b1 AND      expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.AND);     :}
                 |  expression_bool:b1 OR       expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.OR);      :}
                 |  expression_bool:b1 DIFF     expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.DIFF);    :}
                 |  expression_bool:b1 EQ       expression_bool:b2      {:  RESULT = new OperationBooleenne(b1, b2, EnumOp.EQUALS);  :}

                 |  NOT expression_bool:b                               {:  RESULT = new OperationBooleenne(b, EnumOp.NOT); :} %prec NOT_U
                 |  LRBRA expression_bool:b RRBRA                       {:  RESULT = b;   :}
                 //|  expression_arith:exp                                {:  RESULT = exp; :}
                 ;
